<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hit & Blow - Random Match</title>
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+1p:wght@400;700;800&display=swap" rel="stylesheet">
    
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <style>
        /* --- v9までの共通スタイル --- */
        :root {
            --my-color: #1a5c9a; --my-light: #3a8cd9;
            --opp-color: #8a0a2a; --opp-light: #b91c4c;
            --bg-color: #4a7a9a; --text-color: #fff;
            --accent-red: #e60012;
            --table-header: #3a5a7a; --table-row-odd: #dbe4f1; --table-row-even: #c8d6e8; --table-text: #1a3a5a;
        }
        body {
            font-family: 'M PLUS 1p', sans-serif;
            background-color: var(--bg-color); color: var(--text-color);
            margin: 0; padding: 0; height: 100vh;
            display: flex; flex-direction: column;
            -webkit-tap-highlight-color: transparent; user-select: none; touch-action: manipulation; overflow: hidden;
        }

        .top-header {
            display: flex; height: 80px; background: linear-gradient(90deg, var(--my-color) 50%, var(--opp-color) 50%); position: relative; flex-shrink: 0;
        }
        .player-info { width: 50%; display: flex; align-items: center; padding: 0 15px; box-sizing: border-box; }
        .player-info.mine { justify-content: flex-start; }
        .player-info.opp { justify-content: flex-end; text-align: right; }
        .avatar {
            width: 50px; height: 50px; border-radius: 50%; background: #ccc;
            border: 3px solid rgba(255,255,255,0.3); display: flex; justify-content: center; align-items: center;
            font-size: 30px; color: #fff; overflow: hidden;
        }
        .player-details { margin: 0 10px; }
        .player-name { font-weight: 800; font-size: 16px; }
        
        .turn-order-badge {
            position: absolute; top: 5px; left: 50%; transform: translateX(-50%); display: flex; gap: 2px;
        }
        .order-label { font-size: 10px; padding: 2px 6px; border-radius: 4px; background: #666; }
        .order-label.active.mine { background: var(--my-light); }
        .order-label.active.opp { background: var(--opp-light); }

        .main-content { flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; position: relative; }

        #gameArea { display: flex; flex-direction: column; height: 100%; }
        .secret-area {
            display: flex; justify-content: space-between; padding: 15px 20px;
            background: linear-gradient(90deg, #124275 50%, #690620 50%); flex-shrink: 0;
        }
        .num-cards { display: flex; gap: 5px; }
        .num-card {
            width: 45px; height: 55px; background: #fff; border-radius: 8px;
            display: flex; justify-content: center; align-items: center;
            font-size: 36px; font-weight: 800; color: var(--my-color);
            box-shadow: 0 4px 0 rgba(0,0,0,0.2);
        }
        .num-card.question {
            background: linear-gradient(135deg, #5a8ca8, #3a6c88); color: #fff;
            font-size: 32px; text-shadow: 0 1px 2px rgba(0,0,0,0.3); position: relative;
        }

        .history-container { flex-grow: 1; display: flex; padding: 10px; gap: 10px; overflow: hidden; }
        .history-col { width: 50%; background: #fff; border-radius: 12px; overflow: hidden; display: flex; flex-direction: column; }
        .history-header {
            background: var(--table-header); color: #fff; font-weight: 700; font-size: 14px;
            padding: 8px; display: flex; justify-content: space-between;
        }
        .h-head-left { text-align: left; flex-grow: 1; padding-left: 10px; }
        .history-list { flex-grow: 1; overflow-y: auto; -webkit-overflow-scrolling: touch; display: flex; flex-direction: column; }
        .h-row {
            display: flex; padding: 6px 4px; color: var(--table-text);
            font-weight: 700; font-size: 18px; font-family: 'Courier New', monospace;
            border-bottom: 1px solid rgba(0,0,0,0.1); flex-shrink: 0; align-items: center;
        }
        .h-row:nth-child(odd) { background: var(--table-row-odd); }
        .h-row:nth-child(even) { background: var(--table-row-even); }
        .h-turn { width: 20px; font-size: 11px; color: #8899aa; border-right: 1px solid rgba(0,0,0,0.1); margin-right: 5px; text-align: center; font-family: 'M PLUS 1p', sans-serif; }
        .h-num { flex-grow: 1; text-align: center; letter-spacing: 3px; }
        .h-val { width: 25px; text-align: center; }
        .h-val.hit-3 { color: var(--accent-red); }

        /* 入力画面 */
        .overlay-screen {
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            height: 100%; background: rgba(0,0,0,0.2); color: #fff;
        }
        .setup-title { font-size: 20px; margin-bottom: 20px; font-weight: bold; }
        .setup-input {
            font-size: 60px; font-weight: 800; letter-spacing: 15px; color: #fff;
            text-shadow: 0 2px 10px rgba(0,0,0,0.5); margin-bottom: 40px; font-family: 'Courier New', monospace;
        }
        .overlay-status { font-size: 16px; color: #eee; margin-top: 10px; font-weight:bold; animation: blink 1.5s infinite; }
        @keyframes blink { 50% { opacity: 0.5; } }

        /* マッチングボタン */
        .match-btn {
            background: linear-gradient(135deg, #ff9500, #ff3b30);
            color: #fff; font-size: 24px; font-weight: 800; padding: 20px 40px;
            border: 4px solid #fff; border-radius: 50px; cursor: pointer;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3); transition: transform 0.1s;
        }
        .match-btn:active { transform: scale(0.95); }

        .footer-area { background: var(--bg-color); padding: 10px 15px 30px; position: relative; flex-shrink: 0; z-index: 10; }
        .footer-bg-curve { position: absolute; top: -20px; left: 0; width: 100%; height: 30px; background: var(--bg-color); border-radius: 50% 50% 0 0 / 100% 100% 0 0; z-index: 0; }
        .status-bar { position: relative; z-index: 1; display: flex; align-items: center; margin-bottom: 15px; }
        .timer-circle {
            width: 50px; height: 50px; background: #fff; border-radius: 50%;
            border: 4px solid #3a5a7a; display: flex; justify-content: center; align-items: center;
            font-size: 20px; font-weight: 800; color: var(--table-text); position: relative;
        }
        .input-status-container { flex-grow: 1; margin-left: 15px; display: flex; flex-direction: column; align-items: center; }
        .game-message { font-size: 12px; font-weight: 700; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.5); margin-bottom: 5px; }
        .input-display-box {
            width: 200px; height: 45px; background: linear-gradient(to bottom, #4a7a9a, #2a5a7a);
            border: 2px solid #fff; border-radius: 10px; box-shadow: inset 0 4px 8px rgba(0,0,0,0.3);
            display: flex; justify-content: center; align-items: center;
            font-size: 28px; font-weight: 800; letter-spacing: 8px; color: #fff; text-shadow: 0 0 10px rgba(255,255,255,0.7);
        }

        .keypad-area { position: relative; z-index: 1; display: grid; grid-template-columns: repeat(5, 1fr); gap: 6px; margin-bottom: 8px; }
        .key-btn {
            height: 55px; background: linear-gradient(to bottom, #e0e0e0, #c0c0c0);
            border: none; border-radius: 8px; font-size: 24px; font-weight: 800; color: #333; box-shadow: 0 3px 0 #999;
        }
        .key-btn:active.key-active { transform: translateY(3px); box-shadow: none; background: #b0b0b0; }
        .ctrl-area { position: relative; z-index: 1; display: flex; gap: 8px; }
        .ctrl-btn { flex: 1; height: 50px; border: none; border-radius: 8px; font-size: 18px; font-weight: 700; color: #fff; box-shadow: 0 3px 0 rgba(0,0,0,0.3); }
        .del-btn { background: #d9534f; box-shadow: 0 3px 0 #c9302c; }
        .call-btn { background: #5cb85c; box-shadow: 0 3px 0 #4cae4c; }
        .ctrl-btn:active.key-active { transform: translateY(3px); box-shadow: none; opacity: 0.9; }
        .disabled { opacity: 0.5; pointer-events: none; }
        .hidden { display: none !important; }
    </style>
</head>
<body>

    <div class="top-header">
        <div class="player-info mine">
            <div class="avatar"><img src="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23fff'><path d='M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z'/></svg>" width="40"></div>
            <div class="player-details"><div class="player-name">あなた</div></div>
        </div>
        <div class="turn-order-badge">
            <div class="order-label mine" id="badgeP1">先手</div>
            <div class="order-label opp" id="badgeP2">後手</div>
        </div>
        <div class="player-info opp">
            <div class="player-details"><div class="player-name" id="oppName">???</div></div>
            <div class="avatar"><img src="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23fff'><path d='M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm0 14.2c-2.5 0-4.71-1.28-6-3.22.03-1.99 4-3.08 6-3.08 1.99 0 5.97 1.09 6 3.08-1.29 1.94-3.5 3.22-6 3.22z'/></svg>" width="40"></div>
        </div>
    </div>

    <div class="main-content">
        <div id="lobbyArea" class="overlay-screen">
            <button class="match-btn" onclick="startMatching()">対戦相手を探す</button>
            <div id="matchStatus" class="overlay-status hidden">マッチング中...</div>
        </div>

        <div id="setupArea" class="overlay-screen hidden">
            <div class="setup-title">あなたの番号を決めてください</div>
            <div id="setupDisplay" class="setup-input">_ _ _</div>
            <div id="setupStatus" class="overlay-status hidden">相手を待っています...</div>
        </div>

        <div id="gameArea" class="hidden">
            <div class="secret-area">
                <div class="num-cards mine" id="mySecretCards"><div class="num-card">?</div><div class="num-card">?</div><div class="num-card">?</div></div>
                <div class="num-cards opp"><div class="num-card question">?</div><div class="num-card question">?</div><div class="num-card question">?</div></div>
            </div>
            <div class="history-container">
                <div class="history-col mine">
                    <div class="history-header"><div class="h-head-left">あなたの推理</div><div class="h-head-hb">H</div><div class="h-head-hb">B</div></div>
                    <div class="history-list" id="playerLogList"><div class="h-row placeholder"><div class="h-num">- - -</div></div></div>
                </div>
                <div class="history-col opp">
                    <div class="history-header"><div class="h-head-left">相手の推理</div><div class="h-head-hb">H</div><div class="h-head-hb">B</div></div>
                    <div class="history-list" id="oppLogList"><div class="h-row placeholder"><div class="h-num">- - -</div></div></div>
                </div>
            </div>
        </div>
    </div>

    <div class="footer-area">
        <div class="footer-bg-curve"></div>
        <div class="status-bar">
            <div class="timer-circle" id="timerDisplay">60</div>
            <div class="input-status-container">
                <div class="game-message" id="gameMessage">マッチングしてください</div>
                <div class="input-display-box" id="footerInputDisplay">_ _ _</div>
            </div>
        </div>
        <div class="keypad-area">
            <button class="key-btn" data-key="0">0</button><button class="key-btn" data-key="1">1</button>
            <button class="key-btn" data-key="2">2</button><button class="key-btn" data-key="3">3</button>
            <button class="key-btn" data-key="4">4</button><button class="key-btn" data-key="5">5</button>
            <button class="key-btn" data-key="6">6</button><button class="key-btn" data-key="7">7</button>
            <button class="key-btn" data-key="8">8</button><button class="key-btn" data-key="9">9</button>
        </div>
        <div class="ctrl-area">
            <button class="ctrl-btn del-btn" data-key="del">DEL</button>
            <button class="ctrl-btn call-btn disabled" data-key="call" id="callBtn">決定</button>
        </div>
    </div>

    <script>
        // --- Firebase Config (User's) ---
        const firebaseConfig = {
            apiKey: "AIzaSyBUqHpWGjezBuMPV76T9FZQz2ChcSEr5Ao",
            authDomain: "hit-and-blow-online.firebaseapp.com",
            projectId: "hit-and-blow-online",
            storageBucket: "hit-and-blow-online.firebasestorage.app",
            messagingSenderId: "817002043792",
            appId: "1:817002043792:web:fcdd4ea0973faba1763b15"
        };
        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();

        // --- Variables ---
        let currentPhase = 'lobby'; // lobby, setup, battle
        let roomId = "";
        let myRole = ""; // "p1" or "p2"
        let currentInput = [];
        let mySecret = [], oppSecret = [];
        let isMyTurn = false;
        let turnCount = 1;
        let timeLeft = 60;
        let timerInterval = null;

        // SE
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playTone(t,f,d){if(audioCtx.state==='suspended')audioCtx.resume();const o=audioCtx.createOscillator(),g=audioCtx.createGain();o.type=t;o.frequency.value=f;g.gain.value=0.08;g.gain.exponentialRampToValueAtTime(0.001,audioCtx.currentTime+d);o.connect(g);g.connect(audioCtx.destination);o.start();o.stop(audioCtx.currentTime+d);}
        const SE={click:()=>playTone('triangle',800,0.05),error:()=>playTone('sawtooth',150,0.15),enter:()=>{playTone('sine',1200,0.08);setTimeout(()=>playTone('sine',600,0.08),50)},win:()=>{[523,659,783,1046].forEach((f,i)=>setTimeout(()=>playTone('square',f,0.2),i*100))},lose:()=>{[300,250,200,150].forEach((f,i)=>setTimeout(()=>playTone('sawtooth',f,0.2),i*150))}};

        // --- UI Events ---
        document.querySelectorAll('button[data-key]').forEach(btn => {
            ['touchstart','mousedown'].forEach(evt => {
                btn.addEventListener(evt, (e) => { e.preventDefault(); handleKey(btn.dataset.key, btn); }, {passive:false});
            });
        });

        function handleKey(key, btnEle) {
            btnEle.classList.add('key-active'); setTimeout(()=>btnEle.classList.remove('key-active'), 100);
            if (currentPhase === 'lobby' || (currentPhase === 'battle' && !isMyTurn) || (currentPhase==='setup' && document.getElementById('setupStatus').classList.contains('hidden')===false)) return;

            if(key === 'del') {
                if(currentInput.length > 0) { currentInput.pop(); SE.click(); }
            } else if(key === 'call') {
                if(currentInput.length !== 3) { SE.error(); return; }
                SE.enter(); executePhaseAction();
            } else {
                const num = parseInt(key);
                if(!currentInput.includes(num) && currentInput.length < 3) {
                    currentInput.push(num); SE.click();
                } else { SE.error(); }
            }
            updateInputDisplay();
        }

        function updateInputDisplay() {
            let d = [...currentInput]; while(d.length < 3) d.push("_");
            let str = d.join(" ");
            document.getElementById('footerInputDisplay').innerText = str;
            document.getElementById('callBtn').classList.toggle('disabled', currentInput.length !== 3);
            if(currentPhase==='setup') document.getElementById('setupDisplay').innerText = str;
        }

        function executePhaseAction() {
            if(currentPhase === 'setup') submitSecret();
            else if(currentPhase === 'battle') submitGuess();
        }

        // --- ★ランダムマッチングのロジック ---
        function startMatching() {
            const btn = document.querySelector('.match-btn');
            btn.disabled = true;
            btn.innerText = "検索中...";
            document.getElementById('matchStatus').classList.remove('hidden');
            document.getElementById('gameMessage').innerText = "対戦相手を探しています...";
            
            // 待機列(waiting_room)を確認
            const waitRef = db.ref('waiting_room');
            
            // トランザクションで「早いもの勝ち」で部屋を取る
            waitRef.transaction((currentData) => {
                if (currentData === null) {
                    // 誰も待っていない -> 自分が待機部屋を作る
                    // 自分のための新しいRoomIDを発行して、それをwaiting_roomに置く
                    const newRoomKey = db.ref('rooms').push().key;
                    return newRoomKey; 
                } else {
                    // 誰かが待っている -> その部屋IDを取得して、waiting_roomを空にする
                    return {}; // 空オブジェクトで削除と同じ扱いにする（値を消す）
                }
            }, (error, committed, snapshot) => {
                if (error) {
                    console.error("Matching error", error);
                    alert("エラーが発生しました。もう一度試してください。");
                    location.reload();
                    return;
                }

                if (committed) {
                    const data = snapshot.val();
                    if (typeof data === 'string') {
                        // case 1: 自分がホストになった (waiting_roomにIDを置いた)
                        roomId = data;
                        myRole = "p1";
                        createRoomAndWait();
                    } else {
                        // case 2: 誰かの部屋に入れた (waiting_roomにあったIDを取得した)
                        // data自体はトランザクション前の値(部屋ID)が入っているはずだが、
                        // transactionの仕様上、snapshotから取得する必要がある場合がある。
                        // ただしここでは戻り値が {} になるので、
                        // トランザクション更新関数内で取得した値を使う必要があるが、
                        // SDKの仕様上、snapshotには「書き込み後の値」が入る。
                        // なので、書き込み前の値が必要だが...
                        
                        // ★簡易実装: 競合が少ない前提で、transactionを使わず再取得する形に修正
                        // （厳密なQueueは複雑になるため、ここでは「一度読んで、あれば入る、なければ作る」方式にする）
                        // ※上のtransactionロジックだと取得したIDが取れないため。
                    }
                }
            });
            
            // ↑トランザクションが複雑なので、より確実な「検索 -> 作成」フローに書き換えます
            simpleMatching();
        }

        function simpleMatching() {
             const waitRef = db.ref('waiting_room');
             waitRef.get().then((snap) => {
                 if(snap.exists()) {
                     // 誰か待っている！
                     const targetRoomId = snap.val();
                     // その部屋が本当に空いているか確認しつつ、waitingを消す
                     waitRef.remove().then(() => {
                         // 成功したら入室
                         roomId = targetRoomId;
                         myRole = "p2";
                         joinAsGuest();
                     }).catch(() => {
                         // タッチの差で誰かに取られた -> もう一回検索
                         setTimeout(simpleMatching, 500);
                     });
                 } else {
                     // 誰もいない -> 部屋を作って待つ
                     roomId = db.ref('rooms').push().key;
                     myRole = "p1";
                     
                     // Room情報作成
                     db.ref('rooms/' + roomId).set({
                         p1: { active: true },
                         status: "waiting",
                         turnCount: 1,
                         currentTurn: "p1"
                     });
                     
                     // 待機場所に置く
                     waitRef.set(roomId);
                     
                     // 誰かが入ってくるのを待つ
                     waitForGuest();
                 }
             });
        }

        function waitForGuest() {
            // p2が入ってきたか監視
            db.ref('rooms/' + roomId + '/p2').on('value', (snap) => {
                if(snap.exists()) {
                    // マッチング成立！
                    db.ref('waiting_room').remove(); // 念のため消す
                    goToSetup();
                }
            });
            // 切断時処理
            db.ref('rooms/' + roomId + '/p1').onDisconnect().remove();
            db.ref('waiting_room').onDisconnect().remove();
        }

        function joinAsGuest() {
            db.ref('rooms/' + roomId).update({
                p2: { active: true },
                status: "setup"
            });
            goToSetup();
        }

        // --- 以降、v9と同じゲーム進行ロジック ---
        function goToSetup() {
            currentPhase = 'setup';
            currentInput = []; updateInputDisplay();
            document.getElementById('lobbyArea').classList.add('hidden');
            document.getElementById('setupArea').classList.remove('hidden');
            document.getElementById('oppName').innerText = "対戦相手";
            document.getElementById('gameMessage').innerText = "番号を決めて、決定を押してください";
            document.getElementById('callBtn').classList.remove('disabled');
            
            if(myRole === 'p1') document.getElementById('badgeP1').classList.add('active');
            else document.getElementById('badgeP2').classList.add('active');
        }

        function submitSecret() {
            mySecret = [...currentInput];
            db.ref(`rooms/${roomId}/${myRole}/secret`).set(mySecret);
            db.ref(`rooms/${roomId}/${myRole}/ready`).set(true);

            document.getElementById('setupStatus').classList.remove('hidden');
            document.getElementById('callBtn').classList.add('disabled');
            document.getElementById('gameMessage').innerText = "相手の決定を待っています...";

            db.ref(`rooms/${roomId}`).on('value', (snap) => {
                const data = snap.val();
                if(data.p1 && data.p1.ready && data.p2 && data.p2.ready) {
                    const oppRole = myRole === 'p1' ? 'p2' : 'p1';
                    oppSecret = data[oppRole].secret;
                    startBattle();
                }
            });
        }

        function startBattle() {
            db.ref(`rooms/${roomId}`).off();
            currentPhase = 'battle';
            currentInput = []; updateInputDisplay();
            
            document.getElementById('setupArea').classList.add('hidden');
            document.getElementById('gameArea').classList.remove('hidden');
            document.getElementById('callBtn').innerText = "CALL";
            
            const myCards = document.getElementById('mySecretCards').children;
            for(let i=0; i<3; i++) myCards[i].innerText = mySecret[i];
            document.querySelectorAll('.placeholder').forEach(el=>el.remove());

            db.ref(`rooms/${roomId}/currentTurn`).on('value', (snap) => {
                isMyTurn = (snap.val() === myRole);
                updateTurnUI();
            });

            db.ref(`rooms/${roomId}/history`).on('child_added', (snap) => {
                const log = snap.val();
                const isMe = (log.player === myRole);
                addLog(isMe ? 'playerLogList' : 'oppLogList', log.guess, log.result, log.turnCount);
                if(log.result.hit === 3) setTimeout(() => finishGame(isMe), 500);
            });
            
            db.ref(`rooms/${roomId}/turnCount`).on('value', (s) => turnCount = s.val());
        }

        function updateTurnUI() {
            clearInterval(timerInterval);
            timeLeft = 60; document.getElementById('timerDisplay').innerText = timeLeft;
            
            if(isMyTurn) {
                document.getElementById('gameMessage').innerText = `あなたのターン (${turnCount}手目)`;
                document.getElementById('callBtn').classList.remove('disabled');
                document.getElementById('badgeP1').classList.toggle('active', myRole==='p1');
                document.getElementById('badgeP2').classList.toggle('active', myRole==='p2');

                timerInterval = setInterval(() => {
                    timeLeft--; document.getElementById('timerDisplay').innerText = timeLeft<10?"0"+timeLeft:timeLeft;
                    if(timeLeft<=0) { clearInterval(timerInterval); while(currentInput.length<3){let n=Math.floor(Math.random()*10);if(!currentInput.includes(n))currentInput.push(n);} submitGuess(); }
                }, 1000);
            } else {
                document.getElementById('gameMessage').innerText = `相手は考えています... (${turnCount}手目)`;
                document.getElementById('callBtn').classList.add('disabled');
                document.getElementById('badgeP2').classList.toggle('active', myRole==='p1');
                document.getElementById('badgeP1').classList.toggle('active', myRole==='p2');
            }
        }

        function submitGuess() {
            const guess = [...currentInput];
            const result = checkHitBlow(guess, oppSecret);
            
            db.ref(`rooms/${roomId}/history`).push({ player: myRole, guess: guess, result: result, turnCount: turnCount });

            currentInput = []; updateInputDisplay();

            if(result.hit !== 3) {
                const nextTurn = myRole === 'p1' ? 'p2' : 'p1';
                if(myRole === 'p2') db.ref(`rooms/${roomId}/turnCount`).transaction(c => (c||1)+1);
                db.ref(`rooms/${roomId}/currentTurn`).set(nextTurn);
            }
        }

        function checkHitBlow(g, t) {
            let h=0, b=0;
            for(let i=0;i<3;i++){ if(g[i]===t[i])h++; else if(t.includes(g[i]))b++; }
            return {hit:h, ball:b};
        }

        function addLog(id, g, r, t) {
            const row = document.createElement('div'); row.className = 'h-row';
            row.innerHTML = `<div class="h-turn">${t}</div><div class="h-num">${g.join(" ")}</div><div class="h-val ${r.hit===3?'hit-3':''}">${r.hit}</div><div class="h-val">${r.ball}</div>`;
            const list = document.getElementById(id); list.appendChild(row); list.scrollTop = list.scrollHeight;
        }

        function finishGame(isWin) {
            clearInterval(timerInterval); db.ref(`rooms/${roomId}`).off();
            if(isWin){ SE.win(); alert("YOU WIN!"); } else { SE.lose(); alert("YOU LOSE..."); }
            location.reload();
        }
    </script>
</body>
</html>
